<!DOCTYPE html>
<html lang="he" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="{{ url_for('static', path='favicon.png') }}" />
    <title>תמלול</title>
    <script src="https://cdn.jsdelivr.net/npm/html-docx-js/dist/html-docx.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
      :root {
        --bg-color: #f5f5f5;
        --container-bg: #ffffff;
        --text-color: #333333;
        --border-color: #e0e0e0;
        --primary-color: #4caf50;
        --secondary-color: #f8f9fa;
        --input-bg: #ffffff;
      }

      [data-theme="dark"] {
        --bg-color: #1a1a1a;
        --container-bg: #2d2d2d;
        --text-color: #e0e0e0;
        --border-color: #555555;
        --primary-color: #66bb6a;
        --secondary-color: #3a3a3a;
        --input-bg: #1e1e1e;
      }

      body {
        font-family: Arial, sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        margin: 0;
        background-color: var(--bg-color);
        color: var(--text-color);
      }
      .container {
        background-color: var(--container-bg);
        padding: 2rem;
        border-radius: 16px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        text-align: center;
        width: 80%;
        max-width: 600px;
        position: relative;
      }
      .theme-toggle {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: none;
        border: none;
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 50%;
        transition: background-color 0.2s;
      }
      .theme-toggle:hover {
        background-color: #f0f0f0;
      }
      .theme-toggle svg,
      .theme-toggle i[data-lucide] {
        width: 24px;
        height: 24px;
        color: #666;
      }
      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
      }
      .modal.show {
        display: block;
      }
      .modal-content {
        background-color: var(--container-bg);
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 1.5rem;
        border-radius: 12px;
        width: 90%;
        max-width: 480px;
        max-height: 90vh;
        overflow-y: auto;
        text-align: right;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
      }
      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.25rem;
        padding-bottom: 0.75rem;
      }
      .modal-header h2 {
        margin: 0;
        font-size: 1.4rem;
        color: var(--text-color);
      }
      .close {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        padding: 0;
        color: var(--text-color);
      }
      .close:hover {
        color: var(--primary-color);
      }
      .form-group {
        margin-bottom: 1rem;
        text-align: left;
      }
      .form-group label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: bold;
        color: var(--text-color);
      }
      .form-group input {
        width: 100%;
        padding: 0.5rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 1rem;
        box-sizing: border-box;
        text-align: left;
        direction: ltr;
        background-color: var(--input-bg);
        color: var(--text-color);
      }
      .form-group input:focus {
        outline: none;
        border-color: var(--primary-color);
      }
      .form-help a {
        color: var(--primary-color);
        text-decoration: none;
        font-weight: 600;
      }
      .form-help a:hover {
        text-decoration: underline;
      }
      .modal-buttons {
        display: flex;
        justify-content: flex-start;
        gap: 0.75rem;
        margin-top: 1.5rem;
        padding-top: 1rem;
      }
      .btn {
        padding: 0.6rem 1.2rem;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 500;
        transition: all 0.2s ease;
        min-height: 40px;
      }
      .btn-primary {
        background-color: var(--primary-color);
        color: white;
      }
      .btn-secondary {
        background-color: var(--secondary-color);
        color: var(--text-color);
        border: 1px solid var(--border-color);
      }
      .btn-secondary:hover {
        background-color: var(--container-bg);
        border-color: var(--primary-color);
        opacity: 1;
      }
      .btn:hover {
        opacity: 0.85;
      }
      .btn-primary:hover {
        opacity: 0.9;
      }

      .settings-section {
        margin-bottom: 1.5rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid var(--border-color);
      }
      .settings-section:last-of-type {
        border-bottom: none;
        margin-bottom: 0.5rem;
      }
      .settings-section h3 {
        font-size: 1.1rem;
        color: var(--text-color);
        margin: 0 0 0.75rem 0;
        font-weight: 600;
        text-align: right;
      }
      .form-label {
        display: block;
        font-weight: 500;
        color: var(--text-color);
        margin-bottom: 0.5rem;
        text-align: right;
        font-size: 0.95rem;
      }
      .form-help {
        display: block;
        font-size: 0.8rem;
        color: var(--text-color);
        opacity: 0.65;
        margin-top: 0.25rem;
        text-align: right;
        line-height: 1.3;
      }
      .radio-group {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .radio-option {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        padding: 0.6rem 0.75rem;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
        background-color: var(--secondary-color);
        direction: rtl;
        min-height: 44px;
        position: relative;
      }
      .radio-option:hover {
        border-color: var(--primary-color);
        background-color: var(--container-bg);
      }
      .radio-option input[type="radio"] {
        margin: 0;
        width: 16px;
        height: 16px;
        accent-color: var(--primary-color);
        flex-shrink: 0;
        position: absolute;
        left: 0.75rem;
      }
      .radio-option .radio-content {
        flex: 1;
        text-align: right;
        direction: rtl;
        padding-left: 2rem;
      }
      .radio-option .radio-text {
        font-weight: 500;
        color: var(--text-color);
        font-size: 0.9rem;
        display: block;
        margin-bottom: 0.1rem;
        text-align: right;
        direction: rtl;
      }
      .radio-option small {
        font-size: 0.75rem;
        color: var(--text-color);
        opacity: 0.6;
        line-height: 1.2;
        text-align: right;
        direction: rtl;
      }
      .radio-option input[type="radio"]:checked ~ .radio-content .radio-text {
        color: var(--primary-color);
        font-weight: 600;
      }
      h1 {
        margin-bottom: 2rem;
      }
      #drop-area {
        border: 2px dashed var(--border-color);
        border-radius: 12px;
        padding: 2rem;
        cursor: pointer;
        margin-bottom: 1rem;
        background: linear-gradient(
          135deg,
          var(--secondary-color) 0%,
          rgba(76, 175, 80, 0.12) 50%,
          var(--secondary-color) 100%
        );
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }
      #drop-area::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
          45deg,
          transparent 40%,
          rgba(76, 175, 80, 0.03) 50%,
          transparent 60%
        );
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      #drop-area:hover::before {
        opacity: 1;
      }
      #drop-area:hover {
        border-color: var(--primary-color);
        background: linear-gradient(
          135deg,
          rgba(76, 175, 80, 0.08) 0%,
          rgba(76, 175, 80, 0.15) 50%,
          rgba(76, 175, 80, 0.08) 100%
        );
        transform: translateY(-2px);
      }
      #drop-area.highlight {
        border-color: var(--primary-color);
        background: linear-gradient(
          135deg,
          rgba(76, 175, 80, 0.1) 0%,
          rgba(76, 175, 80, 0.2) 50%,
          rgba(76, 175, 80, 0.1) 100%
        );
        transform: translateY(-3px);
      }
      #file-input {
        display: none;
      }
      #file-name {
        margin-top: 1rem;
        font-weight: bold;
      }
      #transcribe-btn {
        background-color: var(--primary-color);
        color: white;
        border: none;
        padding: 0.75rem 1.5rem;
        font-size: 1rem;
        cursor: pointer;
        border-radius: 8px;
        margin-top: 1rem;
        transition: all 0.3s ease;
      }
      #transcribe-btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
      }
      #transcribe-btn:disabled {
        background-color: var(--border-color);
        cursor: not-allowed;
      }
      /* Ensure perfect alignment of language select and transcribe button */
      .transcribe-controls #transcribe-btn {
        margin-top: 0;
        height: 40px;
        padding: 0 1rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      .transcribe-controls {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        margin-top: 1rem;
      }
      #language-select {
        background-color: var(--secondary-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        height: 40px;
        padding: 0 0.75rem; /* ~12px to match button's horizontal padding scale */
        color: var(--text-color);
        font-size: 1rem;
      }
      #progress-container {
        width: 100%;
        background-color: #f0f0f0;
        border-radius: 4px;
        margin-top: 1rem;
        display: none;
      }
      #progress-bar {
        width: 0;
        height: 20px;
        background-color: #4caf50;
        border-radius: 4px;
        transition: width 0.3s;
      }
      #transcription-container {
        position: relative;
        margin: 1rem auto 0;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      #transcription {
        width: 100%;
        height: 200px;
        border: 2px solid var(--border-color);
        padding: 1rem;
        text-align: right;
        white-space: pre-wrap;
        overflow-y: auto;
        resize: vertical;
        font-size: 1rem;
        border-radius: 8px;
        background-color: var(--input-bg);
        color: var(--text-color);
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        line-height: 1.5;
      }
      .speaker {
        font-weight: bold;
      }
      .speaker-1 {
        color: #2196f3;
      } /* Blue */
      .speaker-2 {
        color: #4caf50;
      } /* Green */
      .speaker-3 {
        color: #ff9800;
      } /* Orange */
      .speaker-4 {
        color: #e91e63;
      } /* Pink */
      .speaker-5 {
        color: #9c27b0;
      } /* Purple */
      .speaker-6 {
        color: #f44336;
      } /* Red */
      .speaker-7 {
        color: #00bcd4;
      } /* Cyan */
      .speaker-8 {
        color: #8bc34a;
      } /* Light Green */
      .speaker-9 {
        color: #ffc107;
      } /* Amber */
      .speaker-10 {
        color: #607d8b;
      } /* Blue Grey */
      /* Dark theme speaker colors */
      [data-theme="dark"] .speaker-1 {
        color: #64b5f6;
      }
      [data-theme="dark"] .speaker-2 {
        color: #81c784;
      }
      [data-theme="dark"] .speaker-3 {
        color: #ffb74d;
      }
      [data-theme="dark"] .speaker-4 {
        color: #f06292;
      }
      [data-theme="dark"] .speaker-5 {
        color: #ba68c8;
      }
      [data-theme="dark"] .speaker-6 {
        color: #ef5350;
      }
      [data-theme="dark"] .speaker-7 {
        color: #4dd0e1;
      }
      [data-theme="dark"] .speaker-8 {
        color: #aed581;
      }
      [data-theme="dark"] .speaker-9 {
        color: #ffd54f;
      }
      [data-theme="dark"] .speaker-10 {
        color: #90a4ae;
      }
      .action-buttons {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-top: 1rem;
        margin-bottom: 0.5rem;
      }
      .actions-right,
      .actions-left {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .action-buttons button {
        background-color: var(--secondary-color);
        border: 1px solid var(--border-color);
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 8px;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .action-buttons button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .download-menu {
        position: relative;
      }
      .download-menu > button#download-menu-btn {
        position: relative;
      }
      .download-menu > button#download-menu-btn:disabled {
        cursor: not-allowed;
      }
      .download-menu {
        display: inline-block;
      }
      .download-menu::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        height: 6px;
      }
      .download-dropdown {
        display: none;
        position: absolute;
        top: 100%;
        left: 0;
        margin-top: 0;
        background: var(--container-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        padding: 0.4rem 0;
        min-width: 160px;
        z-index: 200;
        direction: rtl;
        pointer-events: auto;
      }
      .download-menu:hover {
        overflow: visible;
      }
      .download-menu:hover .download-dropdown {
        display: block;
      }
      .download-menu:hover .download-dropdown {
        display: block;
      }
      .download-dropdown button {
        background: none;
        border: none;
        width: 100%;
        text-align: right;
        padding: 0.45rem 0.9rem;
        cursor: pointer;
        font-size: 0.8rem;
        color: var(--text-color);
        display: flex;
        align-items: center;
        gap: 0.4rem;
        direction: rtl;
      }
      .download-dropdown-header {
        font-size: 0.7rem;
        font-weight: 600;
        letter-spacing: 0.5px;
        padding: 0.35rem 0.9rem 0.25rem;
        color: var(--text-color);
        opacity: 0.7;
        pointer-events: none;
        border-bottom: 1px solid var(--border-color);
        margin-bottom: 0.2rem;
      }
      .download-dropdown button:hover {
        background: var(--secondary-color);
        color: var(--primary-color);
      }
      .download-dropdown button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .hidden-download-original {
        display: none !important;
      }
      /* Standard inline SVG sizing inside action buttons */
      .action-buttons button svg {
        width: 20px;
        height: 20px;
      }
      /* Active indication for text-format toggle */
      .action-buttons button.toggle-active {
        background-color: var(--primary-color);
        border-color: var(--primary-color);
        color: #ffffff;
      }
      .action-buttons button.toggle-active i[data-lucide] {
        color: #ffffff;
      }
      .action-buttons button.toggle-active svg {
        color: #ffffff;
      }
      /* Toggle emojis sizing */
      #timestamps-toggle,
      #diarization-toggle {
        font-size: 18px;
        line-height: 1;
      }
      #copy-btn {
        background-color: var(--secondary-color);
        border: 1px solid var(--border-color);
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 8px;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #copy-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      #copy-btn svg {
        width: 20px;
        height: 20px;
        color: var(--text-color);
      }
      #download-menu-btn svg {
        width: 20px;
        height: 20px;
        color: var(--text-color);
      }
      #download-btn {
        background-color: var(--secondary-color);
        border: 1px solid var(--border-color);
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 8px;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
      }
      #download-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      #download-docx-btn {
        background-color: var(--secondary-color);
        border: 1px solid var(--border-color);
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 8px;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #download-docx-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      #download-docx-btn svg {
        width: 20px;
        height: 20px;
        color: var(--text-color);
      }
      .support-link {
        margin-top: 0.5rem;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 0.5rem;
        text-decoration: none;
        color: #000000;
        font-weight: bold;
        transition: opacity 0.2s;
        flex-direction: row-reverse;
      }
      .support-link:hover {
        opacity: 0.8;
      }
      .support-link img {
        width: 24px;
        height: 24px;
      }
      .links-container {
        margin-top: 1.5rem;
        display: flex;
        justify-content: center;
        gap: 0.5rem;
        flex-direction: column;
        align-items: center;
      }
      .contact-link {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 0.5rem;
        text-decoration: none;
        color: #2196f3;
        font-weight: bold;
        transition: opacity 0.2s;
        flex-direction: row-reverse;
      }
      .contact-link:hover {
        opacity: 0.8;
      }
      .contact-link svg {
        width: 24px;
        height: 24px;
      }
      .divider {
        width: 80%;
        height: 1px;
        background-color: #e0e0e0;
        margin: 1rem 0;
      }
      .display-options {
        margin-top: 1rem;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        gap: 1rem;
      }
      .slider-container {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .switch {
        position: relative;
        display: inline-block;
        width: 48px;
        height: 24px;
      }
      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.4s;
        border-radius: 24px;
      }
      .slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
      }
      input:checked + .slider {
        background-color: #4caf50;
      }
      input:checked + .slider:before {
        transform: translateX(24px);
      }

      .toast-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 2000;
      }
      .toast {
        background-color: var(--container-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 1rem 1.5rem;
        margin-bottom: 10px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        transform: translateX(400px);
        opacity: 0;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        min-width: 300px;
        max-width: 420px;
        direction: rtl;
        text-align: right;
        line-height: 1.4;
        white-space: normal;
      }
      .toast.show {
        transform: translateX(0);
        opacity: 1;
      }
      .toast.success {
        border-left: 4px solid var(--primary-color);
      }
      .toast.error {
        border-left: 4px solid #f44336;
      }
      .toast-message {
        flex: 1;
        color: var(--text-color);
        white-space: normal;
      }

      .file-preview {
        display: none;
        background-color: var(--secondary-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 1rem;
        margin-top: 1rem;
        text-align: right;
      }
      .file-preview.show {
        display: block;
      }
      .file-info {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
        flex-direction: row-reverse;
      }
      .file-details {
        flex: 1;
        text-align: left;
      }
      .file-details strong {
        display: block;
        margin-bottom: 0.5rem;
        color: var(--text-color);
      }
      .file-size {
        font-size: 0.9rem;
        color: var(--text-color);
        opacity: 0.7;
      }
      .remove-file-btn {
        background-color: #f2554a;
        color: white;
        border: none;
        border-radius: 6px;
        padding: 0.5rem 1rem;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.3s ease;
      }
      .remove-file-btn:hover {
        background-color: #f6463a;
        transform: translateY(-1px);
      }
      .site-footer {
        margin-top: 2rem;
        font-size: 0.75rem;
        color: #777;
        text-align: center;
        direction: rtl;
      }
      [data-theme="dark"] .site-footer {
        color: #aaa;
      }
      .site-footer a {
        color: var(--primary-color);
        text-decoration: none;
        font-weight: 600;
      }
      .site-footer a:hover {
        text-decoration: underline;
      }

      /* Localization layout adjustments */
      html[dir] .modal-content {
        text-align: start;
      }
      html[dir] .modal .form-group {
        text-align: start;
      }
      html[dir] .modal .radio-content,
      html[dir] .modal .radio-option .radio-text,
      html[dir] .modal .form-help {
        text-align: start;
        direction: inherit;
      }
      html[dir] .modal .radio-option {
        direction: inherit;
      }
    </style>
  </head>
  <body>
    <div class="toast-container" id="toast-container"></div>

    <div class="container">
      <button
        class="theme-toggle"
        id="theme-toggle"
        onclick="toggleTheme()"
        title="החלף נושא"
      >
        <i data-lucide="sun" id="sun-icon"></i>
        <i data-lucide="moon" id="moon-icon" style="display: none"></i>
      </button>
      <h1>תמלול</h1>
      <div id="drop-area">
        <p>גרור קובץ לכאן או לחץ לבחירת קובץ</p>
        <input type="file" id="file-input" accept="audio/*,video/*" />
      </div>

      <div class="file-preview" id="file-preview">
        <div class="file-info">
          <div class="file-details">
            <strong id="preview-file-name">קובץ נבחר</strong>
            <div class="file-size" id="preview-file-size" dir="ltr">
              <span>גודל קובץ</span>
            </div>
          </div>
          <button class="remove-file-btn" onclick="removeFile()">
            הסר קובץ
          </button>
        </div>
      </div>

      <div id="file-name"></div>
      <div class="transcribe-controls">
        <button id="transcribe-btn" disabled>תמלל</button>
      </div>
      <div id="progress-container">
        <div id="progress-bar"></div>
      </div>
      <div class="action-buttons">
        <div class="actions-right">
          <button
            id="text-format-toggle"
            title="פורמט הטקסט: טקסט רציף"
            aria-label="פורמט הטקסט"
          >
            <svg
              id="text-format-icon"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
              aria-hidden="true"
            >
              <path d="M4 6h16M10 12h10M4 18h16" />
            </svg>
          </button>
          <button id="timestamps-toggle" title="קודי זמן" aria-label="קודי זמן">
            🕒
          </button>
          <button id="diarization-toggle" title="דוברים" aria-label="דוברים">
            🗣️
          </button>
        </div>

        <div class="actions-left">
          <button id="copy-btn" disabled data-i18n-title="copyText">
            <i data-lucide="copy"></i>
          </button>

          <div class="download-menu">
            <button id="download-menu-btn" disabled data-i18n-title="downloads">
              <i data-lucide="download"></i>
            </button>
            <div class="download-dropdown">
              <div class="download-dropdown-header" data-i18n="downloadAs">
                הורד כ...
              </div>
              <button type="button" data-action="vtt" disabled id="menu-vtt">
                VTT
              </button>
              <button type="button" data-action="srt" disabled id="menu-srt">
                SRT
              </button>
              <button type="button" data-action="docx" disabled id="menu-docx">
                <span data-i18n="wordDocx">Word DOCX</span>
              </button>
              <button type="button" data-action="json" disabled id="menu-json">
                JSON
              </button>
            </div>
          </div>

          <!-- Hidden original buttons kept for existing JS logic -->
          <button
            id="download-btn"
            class="hidden-download-original"
            disabled
            title="הורד כתוביות"
          >
            🎬
          </button>
          <button
            id="download-docx-btn"
            class="hidden-download-original"
            disabled
            title="הורד כמסמך Word"
          ></button>
          <button
            id="export-words-btn"
            class="hidden-download-original"
            disabled
            title="ייצא נתוני תמלול מלאים (JSON)"
          ></button>
        </div>
      </div>
      <div id="transcription-container">
        <div id="transcription" contenteditable="false"></div>
      </div>
    </div>

    <script>
      // Theme management
      function toggleTheme() {
        const html = document.documentElement
        const currentTheme = html.getAttribute("data-theme")
        const newTheme = currentTheme === "dark" ? "light" : "dark"

        html.setAttribute("data-theme", newTheme)
        localStorage.setItem("theme", newTheme)

        // Update icon visibility
        const sunIcon = document.getElementById("sun-icon")
        const moonIcon = document.getElementById("moon-icon")

        if (newTheme === "dark") {
          sunIcon.style.display = "none"
          moonIcon.style.display = "block"
        } else {
          sunIcon.style.display = "block"
          moonIcon.style.display = "none"
        }
      }

      // Initialize theme on page load
      function initTheme() {
        const savedTheme = localStorage.getItem("theme") || "light"
        document.documentElement.setAttribute("data-theme", savedTheme)

        const sunIcon = document.getElementById("sun-icon")
        const moonIcon = document.getElementById("moon-icon")

        if (savedTheme === "dark") {
          sunIcon.style.display = "none"
          moonIcon.style.display = "block"
        } else {
          sunIcon.style.display = "block"
          moonIcon.style.display = "none"
        }
      }

      // Initialize theme immediately (before DOMContentLoaded to prevent flash)
      initTheme()

      // Initialize Lucide icons after DOM is parsed
      document.addEventListener("DOMContentLoaded", () => {
        if (window.lucide && typeof window.lucide.createIcons === "function") {
          window.lucide.createIcons()
        }
        // ממשק ברירת מחדל בעברית
        // Ensure toggles reflect initial defaults/saved state on first load
        updateTextFormatToggleUI()
        updateTimestampsToggleUI()
        updateDiarizationToggleUI()
        // Force diarization enabled by default visually on first load
        if (!displaySettings.diarizationDisplay) {
          displaySettings.diarizationDisplay = "enabled"
          localStorage.setItem(
            "displaySettings",
            JSON.stringify(displaySettings)
          )
          updateDiarizationToggleUI()
        }
        updateTranscriptionDirectionUI()
      })
      const dropArea = document.getElementById("drop-area")
      const fileInput = document.getElementById("file-input")
      const fileName = document.getElementById("file-name")
      const transcribeBtn = document.getElementById("transcribe-btn")
      const progressContainer = document.getElementById("progress-container")
      const progressBar = document.getElementById("progress-bar")
      const transcriptionArea = document.getElementById("transcription")
      const copyBtn = document.getElementById("copy-btn")
      const downloadBtn = document.getElementById("download-btn")
      const downloadDocxBtn = document.getElementById("download-docx-btn")
      const exportWordsBtn = document.getElementById("export-words-btn")
      const textFormatToggleBtn = document.getElementById("text-format-toggle")
      const timestampsToggleBtn = document.getElementById("timestamps-toggle")
      const diarizationToggleBtn = document.getElementById("diarization-toggle")
      // New unified download menu elements
      const downloadMenuBtn = document.getElementById("download-menu-btn")
      const menuVttBtn = document.getElementById("menu-vtt")
      const menuSrtBtn = document.getElementById("menu-srt")
      const menuDocxBtn = document.getElementById("menu-docx")
      const menuJsonBtn = document.getElementById("menu-json")

      let selectedFile = null
      let selectedFiles = []
      let batchMode = false
      const MAX_FILE_SIZE_BYTES = 300 * 1024 * 1024 // 300MB in bytes
      let transcriptionSegments = []
      let activeTranscription = false
      let currentJobId = null

      // Function to get current max file size based on private key usage
      function getMaxFileSize() {
        return MAX_FILE_SIZE_BYTES
      }

      // Function to get max file size text for display
      function getMaxFileSizeText() {
        return "300MB"
      }

      let displaySettings = {
        textFormat: "continuous",
        timestampFormat: "none",
        diarizationDisplay: "enabled",
      }

      function showToast(message, type = "success") {
        const toastContainer = document.getElementById("toast-container")
        const toast = document.createElement("div")
        toast.className = `toast ${type}`

        // Support multi-line messages using \n
        const formatted = (message || "")
          .toString()
          .replace(/\n/g, "<br />")
          .replace(/\\n/g, "<br />")
          .replace(/endpointCheckError/g, "שגיאת בדיקת endpoint")
          .replace(/endpointCheckError/g, "שגיאת בדיקת endpoint")
        toast.innerHTML = `
          <span class="toast-message">${formatted}</span>
        `

        toastContainer.appendChild(toast)

        setTimeout(() => toast.classList.add("show"), 10)

        // Duration: errors stay longer
        const duration = type === "error" ? 10000 : 3000
        setTimeout(() => {
          toast.classList.remove("show")
          setTimeout(() => toast.remove(), 300)
        }, duration)
      }

      function showFilePreview(file) {
        const preview = document.getElementById("file-preview")
        const fileName = document.getElementById("preview-file-name")
        const fileSize = document.getElementById("preview-file-size")

        fileName.textContent = file.name
        fileSize.textContent = formatFileSize(file.size)

        preview.classList.add("show")
        document.getElementById("file-name").style.display = "none"
      }

      function removeFile() {
        selectedFile = null
        transcribeBtn.disabled = true
        document.getElementById("file-preview").classList.remove("show")
        document.getElementById("file-name").style.display = "block"
        document.getElementById("file-name").textContent = ""
        fileInput.value = ""
        showToast("הקובץ הוסר בהצלחה", "success")
      }

      function formatFileSize(bytes) {
        if (bytes === 0) return "0 Bytes"
        const k = 1024
        const sizes = ["Bytes", "KB", "MB", "GB"]
        const i = Math.floor(Math.log(bytes) / Math.log(k))
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i]
      }

      function handleFiles(files) {
        const list = Array.from(files || [])
        if (!list.length) return

        if (list.length > 1) {
          const maxSize = getMaxFileSize()
          const maxText = getMaxFileSizeText()
          const valid = []
          for (const f of list) {
            if (f.size > maxSize) {
              showToast(
                `הקובץ גדול מדי. הגודל המקסימלי המותר הוא ${maxText}: ${f.name}`,
                "error"
              )
              continue
            }
            valid.push(f)
          }
          if (!valid.length) {
            selectedFiles = []
            batchMode = false
            transcribeBtn.disabled = true
            fileName.textContent = ""
            showToast("לא נמצאו קבצים תקינים", "error")
            return
          }
          selectedFiles = valid
          selectedFile = null
          batchMode = true
          transcribeBtn.disabled = false
          document.getElementById("file-preview").classList.remove("show")
          document.getElementById("file-name").style.display = "block"
          document.getElementById(
            "file-name"
          ).textContent = `${valid.length} קבצים נבחרו`
          showToast(`${valid.length} קבצים נבחרו בהצלחה`, "success")
          return
        }

        // Single-file mode
        selectedFile = list[0]
        const maxFileSize = getMaxFileSize()
        const maxFileSizeText = getMaxFileSizeText()
        if (selectedFile.size > maxFileSize) {
          showToast(
            `הקובץ גדול מדי. הגודל המקסימלי המותר הוא ${maxFileSizeText}`,
            "error"
          )
          selectedFile = null
          transcribeBtn.disabled = true
          fileName.textContent = ""
        } else {
          selectedFiles = []
          batchMode = false
          transcribeBtn.disabled = false
          showFilePreview(selectedFile)
          showToast("קובץ נבחר בהצלחה", "success")
        }
      }

      ;["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
        dropArea.addEventListener(eventName, preventDefaults, false)
      })

      function preventDefaults(e) {
        e.preventDefault()
        e.stopPropagation()
      }

      ;["dragenter", "dragover"].forEach((eventName) => {
        dropArea.addEventListener(eventName, highlight, false)
      })
      ;["dragleave", "drop"].forEach((eventName) => {
        dropArea.addEventListener(eventName, unhighlight, false)
      })

      function highlight() {
        dropArea.classList.add("highlight")
      }

      function unhighlight() {
        dropArea.classList.remove("highlight")
      }

      dropArea.addEventListener("drop", handleDrop, false)

      async function handleDrop(e) {
        const dt = e.dataTransfer
        if (dt.items && dt.items.length) {
          const files = await extractFilesFromDataTransfer(dt)
          handleFiles(files)
        } else {
          handleFiles(dt.files)
        }
      }

      async function extractFilesFromDataTransfer(dt) {
        const out = []
        const items = dt.items
        if (!items || !items.length) return Array.from(dt.files || [])

        const traverseEntry = async (entry) => {
          return new Promise((resolve) => {
            try {
              if (entry.isFile) {
                entry.file((file) => resolve([file]))
              } else if (entry.isDirectory) {
                const dirReader = entry.createReader()
                const all = []
                const readAll = () => {
                  dirReader.readEntries(async (entries) => {
                    if (!entries.length) {
                      resolve(all)
                      return
                    }
                    const promises = entries.map((ent) => traverseEntry(ent))
                    Promise.all(promises).then((nested) => {
                      nested.forEach((arr) => all.push(...arr))
                      readAll()
                    })
                  })
                }
                readAll()
              } else {
                resolve([])
              }
            } catch (err) {
              resolve([])
            }
          })
        }

        const entryPromises = []
        for (let i = 0; i < items.length; i++) {
          const item = items[i]
          if (item.webkitGetAsEntry) {
            const entry = item.webkitGetAsEntry()
            if (entry) entryPromises.push(traverseEntry(entry))
          } else if (item.kind === "file") {
            const f = item.getAsFile()
            if (f) out.push(f)
          }
        }

        const nested = await Promise.all(entryPromises)
        nested.forEach((arr) => out.push(...arr))
        return out
      }

      fileInput.addEventListener("change", function () {
        handleFiles(this.files)
      })

      function handleFiles(files) {
        const list = Array.from(files || [])
        if (!list.length) return

        if (list.length > 1) {
          const maxSize = getMaxFileSize()
          const maxText = getMaxFileSizeText()
          const valid = []
          for (const f of list) {
            if (f.size > maxSize) {
              showToast(
                `הקובץ גדול מדי. הגודל המקסימלי המותר הוא ${maxText}: ${f.name}`,
                "error"
              )
              continue
            }
            valid.push(f)
          }
          if (!valid.length) {
            selectedFiles = []
            batchMode = false
            transcribeBtn.disabled = true
            fileName.textContent = ""
            showToast("לא נמצאו קבצים תקינים", "error")
            return
          }
          selectedFiles = valid
          selectedFile = null
          batchMode = true
          transcribeBtn.disabled = false
          document.getElementById("file-preview").classList.remove("show")
          document.getElementById("file-name").style.display = "block"
          document.getElementById(
            "file-name"
          ).textContent = `${valid.length} קבצים נבחרו`
          showToast(`${valid.length} קבצים נבחרו בהצלחה`, "success")
          return
        }

        selectedFile = list[0]
        const maxFileSize = getMaxFileSize()
        const maxFileSizeText = getMaxFileSizeText()
        if (selectedFile.size > maxFileSize) {
          showToast(
            `הקובץ גדול מדי. הגודל המקסימלי המותר הוא ${maxFileSizeText}`,
            "error"
          )
          selectedFile = null
          transcribeBtn.disabled = true
          fileName.textContent = ""
        } else {
          selectedFiles = []
          batchMode = false
          transcribeBtn.disabled = false
          showFilePreview(selectedFile)
          showToast("קובץ נבחר בהצלחה", "success")
        }
      }

      dropArea.addEventListener("click", () => {
        fileInput.removeAttribute("multiple")
        fileInput.click()
      })

      transcribeBtn.addEventListener("click", function () {
        if (batchMode && selectedFiles.length > 0) {
          uploadBatch()
        } else {
          uploadFile()
        }
      })

      function uploadFile() {
        if (!selectedFile) return

        const formData = new FormData()
        formData.append("file", selectedFile)

        transcribeBtn.disabled = true
        progressContainer.style.display = "block"
        progressBar.style.width = "0%"
        transcriptionArea.innerHTML = "מעלה..."
        updateTranscriptionDirectionUI()
        copyBtn.disabled = true
        downloadBtn.disabled = true
        downloadDocxBtn.disabled = true
        exportWordsBtn.disabled = true
        transcriptionSegments = []
        currentJobId = null

        const xhr = new XMLHttpRequest()
        xhr.open("POST", "/upload", true)

        xhr.upload.onprogress = function (event) {
          if (event.lengthComputable) {
            const percentComplete = (event.loaded / event.total) * 100
            progressBar.style.width = percentComplete + "%"
            transcriptionArea.innerHTML = `מעלה... ${percentComplete.toFixed(
              1
            )}%`
          }
        }

        xhr.onload = function () {
          if (xhr.status === 200) {
            const response = JSON.parse(xhr.responseText)
            if (response.error) {
              showError(response.error)
            } else {
              transcriptionArea.innerHTML = "קובץ הועלה. מתחיל בתמלול..."
              pollJobStatus(response.job_id)
            }
          } else {
            let errorMessage = undefined
            try {
              const response = JSON.parse(xhr.responseText)
              if (response.error) {
                errorMessage = response.error
              }
            } catch (e) {
              // If parsing fails, use statusText as fallback
            }

            let reportMessage = `${errorMessage}`

            if (!errorMessage) {
              const currentTime = new Date().toISOString()
              reportMessage = `שגיאה בזמן העלאת קובץ. זמן: ${currentTime}. פרטים: ${xhr.statusText}`
            }

            showError(reportMessage)
          }
        }

        xhr.onerror = function () {
          showError("שגיאת העלאה")
        }

        xhr.send(formData)
      }

      async function uploadBatch() {
        if (!selectedFiles || selectedFiles.length === 0) return

        transcribeBtn.disabled = true
        progressContainer.style.display = "block"
        progressBar.style.width = "0%"
        transcriptionArea.innerHTML = `מתחיל עיבוד אצווה של ${selectedFiles.length} קבצים...`
        updateTranscriptionDirectionUI()
        copyBtn.disabled = true
        downloadBtn.disabled = true
        downloadDocxBtn.disabled = true
        exportWordsBtn.disabled = true
        downloadMenuBtn.disabled = true

        for (let i = 0; i < selectedFiles.length; i++) {
          const file = selectedFiles[i]
          transcriptionArea.innerHTML = `מעלה ${i + 1}/${
            selectedFiles.length
          }: ${file.name}`

          const formData = new FormData()
          formData.append("file", file)

          let jobId = null
          try {
            const resp = await fetch("/upload", {
              method: "POST",
              body: formData,
            })
            const data = await resp.json()
            if (!resp.ok || data.error) {
              const err = data && data.error ? data.error : "שגיאת העלאה"
              showToast(`${file.name}: ${err}`, "error")
              continue
            }
            jobId = data.job_id
          } catch (err) {
            showToast(`${file.name}: שגיאת העלאה`, "error")
            continue
          }

          const results = await pollJobStatusBatch(
            jobId,
            i + 1,
            selectedFiles.length,
            file.name
          )
          if (results && Array.isArray(results) && results.length > 0) {
            try {
              if (
                !window.htmlDocx ||
                typeof window.htmlDocx.asBlob !== "function"
              ) {
                showToast(
                  "ספריית יצירת המסמך לא נטענה. בדקו את החיבור ונסו שוב.",
                  "error"
                )
                continue
              }
              const html = buildDocxHTMLFromSegmentsParam(results)
              const blob = window.htmlDocx.asBlob(html)
              const url = URL.createObjectURL(blob)
              const a = document.createElement("a")
              a.href = url
              a.download = getDocxNameFromOriginal(file.name)
              document.body.appendChild(a)
              a.click()
              document.body.removeChild(a)
              URL.revokeObjectURL(url)
              showToast(`קובץ DOCX ירד: ${file.name}`, "success")
            } catch (err) {
              showToast(`${file.name}: שגיאה ביצירת DOCX`, "error")
            }
          }
        }

        resetUploadState()
        transcriptionArea.innerHTML = "האצווה הושלמה"
      }

      function getDocxNameFromOriginal(originalName) {
        if (!originalName) return "transcription.docx"
        const idx = originalName.lastIndexOf(".")
        if (idx > 0) return originalName.slice(0, idx) + ".docx"
        return originalName + ".docx"
      }

      async function pollJobStatusBatch(jobId, index, total, filename) {
        const pollInterval = 2000
        return new Promise((resolve) => {
          const poll = () => {
            fetch(`/job_status/${jobId}`)
              .then((response) => response.json())
              .then((data) => {
                if (data.error) {
                  showToast(`${filename}: ${data.error}`, "error")
                  resolve(null)
                  return
                }
                if (data.queue_position) {
                  progressBar.style.width = "0%"
                  transcriptionArea.innerHTML = `בתור (${index}/${total}) ${filename} · מקום ${data.queue_position} · ETA ${data.time_ahead}`
                  setTimeout(poll, pollInterval)
                } else if (data.progress !== undefined) {
                  progressBar.style.width = `${data.progress * 100}%`
                  transcriptionArea.innerHTML = `מתמלל (${index}/${total}) ${filename} · ${(
                    data.progress * 100
                  ).toFixed(1)}%`
                  if (data.progress < 1.0) {
                    setTimeout(poll, pollInterval)
                  } else {
                    resolve(data.results || [])
                  }
                } else {
                  setTimeout(poll, pollInterval)
                }
              })
              .catch(() => {
                showToast(`${filename}: שגיאת סטטוס`, "error")
                resolve(null)
              })
          }
          poll()
        })
      }

      function buildDocxHTMLFromSegmentsParam(segments) {
        const docLang = getTranscriptionLanguage()
        const diarizationEnabled =
          displaySettings.diarizationDisplay !== "disabled"
        const speakerColors = {
          1: "#2196F3",
          2: "#4CAF50",
          3: "#FF9800",
          4: "#9C27B0",
          5: "#009688",
          6: "#E91E63",
          7: "#3F51B5",
          8: "#795548",
          9: "#607D8B",
          10: "#8BC34A",
        }
        const esc = (text) =>
          String(text || "").replace(
            /[&<>]/g,
            (c) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;" }[c])
          )

        const lines = []
        const isRTL = ["he", "yi"].includes(docLang)
        lines.push(
          '<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns="http://www.w3.org/TR/REC-html40">'
        )
        lines.push(
          '<head><meta charset="utf-8"><title>Transcript</title></head>'
        )
        lines.push(
          "<body style=\"font-family:'Arial', 'Helvetica', sans-serif; font-size:12pt; direction:" +
            (isRTL ? "rtl" : "ltr") +
            "; text-align:" +
            (isRTL ? "right" : "left") +
            '">'
        )

        if (displaySettings.timestampFormat === "segments") {
          for (let i = 0; i < segments.length; i++) {
            const seg = segments[i]
            const text = esc((seg.text || "").trim())
            const start = formatTimeForDisplay(seg.start || 0)
            const end = formatTimeForDisplay(seg.end || 0)
            if (diarizationEnabled) {
              if (seg.speakers && seg.speakers.length > 0) {
                const speakerNumber =
                  parseInt(seg.speakers[0].replace("SPEAKER_", "")) || 0
                const colorIndex = ((speakerNumber - 1) % 10) + 1
                const color = speakerColors[colorIndex] || "#000000"
                const label =
                  (typeof translateSpeakerLabelText === "function"
                    ? translateSpeakerLabelText(docLang, speakerNumber)
                    : "Speaker " + speakerNumber) + ": "
                lines.push(
                  "<p>[" +
                    start +
                    "-" +
                    end +
                    "] " +
                    '<span style="color:' +
                    color +
                    '; font-weight:700">' +
                    label +
                    "</span>" +
                    text +
                    "</p>"
                )
              } else {
                const unknownText =
                  typeof translateSpeakerUnknownText === "function"
                    ? translateSpeakerUnknownText(docLang)
                    : "Unknown speaker"
                lines.push(
                  "<p>[" +
                    start +
                    "-" +
                    end +
                    "] " +
                    '<span style="font-weight:700">' +
                    unknownText +
                    ": </span>" +
                    text +
                    "</p>"
                )
              }
            } else {
              lines.push("<p>[" + start + "-" + end + "] " + text + "</p>")
            }
          }
        } else {
          let currentSpeaker = undefined
          let bufferParts = []
          let currentLabelHTML = ""

          const flushParagraph = () => {
            if (bufferParts.length === 0) return
            const content = bufferParts.join(" ").trim()
            if (currentLabelHTML) {
              lines.push("<p>" + currentLabelHTML + content + "</p>")
            } else {
              lines.push("<p>" + content + "</p>")
            }
            bufferParts = []
            currentLabelHTML = ""
          }

          for (let i = 0; i < segments.length; i++) {
            const seg = segments[i]
            const rawSpeaker =
              seg.speakers && seg.speakers.length > 0 ? seg.speakers[0] : null
            const segText = esc((seg.text || "").trim())
            const speakerChanged =
              i === 0 ? true : rawSpeaker !== currentSpeaker
            if (speakerChanged) {
              flushParagraph()
              if (diarizationEnabled) {
                if (rawSpeaker) {
                  const speakerNumber =
                    parseInt(rawSpeaker.replace("SPEAKER_", "")) || 0
                  const colorIndex = ((speakerNumber - 1) % 10) + 1
                  const color = speakerColors[colorIndex] || "#000000"
                  const label =
                    (typeof translateSpeakerLabelText === "function"
                      ? translateSpeakerLabelText(docLang, speakerNumber)
                      : "Speaker " + speakerNumber) + ": "
                  currentLabelHTML =
                    '<span style="color:' +
                    color +
                    '; font-weight:700">' +
                    label +
                    "</span>"
                } else {
                  const unknownText =
                    typeof translateSpeakerUnknownText === "function"
                      ? translateSpeakerUnknownText(docLang)
                      : "Unknown speaker"
                  currentLabelHTML =
                    '<span style="font-weight:700">' + unknownText + ": </span>"
                }
              } else {
                currentLabelHTML = ""
              }
              currentSpeaker = rawSpeaker
            }
            if (segText) bufferParts.push(segText)
          }
          flushParagraph()
        }

        lines.push("</body>")
        lines.push("</html>")
        return lines.join("\n")
      }

      function pollJobStatus(jobId) {
        currentJobId = jobId
        const pollInterval = 2000 // Poll every 2 seconds

        function poll() {
          fetch(`/job_status/${jobId}`)
            .then((response) => response.json())
            .then((data) => {
              if (data.error) {
                showError(data.error)
                activeTranscription = false
                return
              }

              if (data.queue_position) {
                const statusMessage = `בתור במקום ${data.queue_position}. זמן משוער להתחלה: ${data.time_ahead}`
                transcriptionArea.innerHTML =
                  `${statusMessage}\n\nממתין לעיבוד...`.replace(/\n/g, "<br>")
                progressBar.style.width = "0%"
                activeTranscription = true
                setTimeout(poll, pollInterval)
              } else if (data.progress !== undefined) {
                progressBar.style.width = `${data.progress * 100}%`
                transcriptionArea.innerHTML = `מתמלל... ${(
                  data.progress * 100
                ).toFixed(1)}%`
                activeTranscription = true

                if (data.progress < 1.0) {
                  setTimeout(poll, pollInterval)
                } else {
                  // Job is complete, update transcription display
                  transcriptionSegments = data.results
                  updateTranscriptionDisplay()
                  resetUploadState()
                  activeTranscription = false
                }
              }
            })
            .catch((error) => {
              console.error("Error:", error)
              showError("אירעה שגיאה בבדיקת סטטוס העבודה")
              activeTranscription = false
            })
        }

        poll()
      }

      function formatWithTimecodes(segments) {
        if (!segments || segments.length === 0) return ""

        const separator =
          displaySettings.textFormat === "continuous" ? " " : "<br>"
        const groups = []
        let currentGroup = []
        let currentTimeMarker = 30 // Start with 30 seconds

        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i]
          currentGroup.push(segment)

          // Check if this segment should end the current group
          const shouldEndGroup =
            (segment.start <= currentTimeMarker &&
              segment.end >= currentTimeMarker) ||
            i === segments.length - 1 || // Last segment
            (i < segments.length - 1 &&
              segments[i + 1].start > currentTimeMarker)

          if (shouldEndGroup) {
            // Get start time of first segment and end time of last segment in group
            const startTime = currentGroup[0].start
            const endTime = currentGroup[currentGroup.length - 1].end

            const groupText =
              displaySettings.diarizationDisplay === "enabled"
                ? joinSegmentsWithSpeakerChanges(
                    currentGroup,
                    separator,
                    "<br>",
                    true
                  )
                : currentGroup.map((seg) => seg.text.trim()).join(separator)

            const formattedStartTime = formatTimeForDisplay(startTime)
            const formattedEndTime = formatTimeForDisplay(endTime)
            groups.push(
              "[" +
                formattedStartTime +
                "-" +
                formattedEndTime +
                "]<br>" +
                groupText
            )

            // Reset for next group
            currentGroup = []
            currentTimeMarker += 30

            // Handle case where we need to advance time marker further
            while (
              i < segments.length - 1 &&
              segments[i + 1].start > currentTimeMarker
            ) {
              currentTimeMarker += 30
            }
          }
        }

        return groups.join("<br><br>")
      }

      function formatTimeForDisplay(seconds) {
        const hours = Math.floor(seconds / 3600)
        const minutes = Math.floor((seconds % 3600) / 60)
        const secs = Math.floor(seconds % 60)

        if (hours > 0) {
          return `${hours}:${String(minutes).padStart(2, "0")}:${String(
            secs
          ).padStart(2, "0")}`
        } else {
          return `${minutes}:${String(secs).padStart(2, "0")}`
        }
      }

      function updateTranscriptionDirectionUI() {
        if (transcriptionArea) {
          transcriptionArea.style.direction = "rtl"
          transcriptionArea.style.textAlign = "right"
        }
      }

      function getTranscriptionLanguage() {
        return "he"
      }

      const SPEAKER_I18N = {
        he: { speaker: "דובר {num}", unknown: "דובר לא מזוהה" },
      }

      function translateSpeakerLabelText(lang, num) {
        const entry = SPEAKER_I18N[lang] || SPEAKER_I18N["en"]
        const template = entry.speaker || "Speaker {num}"
        return String(template).replace("{num}", String(num))
      }

      function translateSpeakerUnknownText(lang) {
        const entry = SPEAKER_I18N[lang] || SPEAKER_I18N["en"]
        return entry.unknown || "Unknown speaker"
      }

      function getSpeakerLabel(segment) {
        const lang = getTranscriptionLanguage()
        if (segment.speakers && segment.speakers.length > 0) {
          const speakerNumber = parseInt(
            segment.speakers[0].replace("SPEAKER_", "")
          )
          const speakerLabelText = translateSpeakerLabelText(
            lang,
            speakerNumber
          )
          return `<span class="speaker speaker-${speakerNumber}">${speakerLabelText}: </span>`
        }
        return `<span class="speaker">${translateSpeakerUnknownText(
          lang
        )}: </span>`
      }

      function getSpeakerLabelPlain(segment) {
        const lang = getTranscriptionLanguage()
        if (segment.speakers && segment.speakers.length > 0) {
          const speakerNumber = parseInt(
            segment.speakers[0].replace("SPEAKER_", "")
          )
          return `${translateSpeakerLabelText(lang, speakerNumber)}: `
        }
        return `${translateSpeakerUnknownText(lang)}: `
      }

      function getPlainTextFromSegments() {
        if (!transcriptionSegments || transcriptionSegments.length === 0) {
          return ""
        }

        let result
        if (displaySettings.timestampFormat === "segments") {
          result = formatWithTimecodesPlain(transcriptionSegments)
        } else {
          const continuousSeparator =
            displaySettings.textFormat === "continuous" ? " " : "\n"
          const segmentSeparator = "\n"
          result = joinSegmentsWithSpeakerChanges(
            transcriptionSegments,
            continuousSeparator,
            segmentSeparator,
            false
          )
        }

        return result
      }

      function formatWithTimecodesPlain(segments) {
        if (!segments || segments.length === 0) return ""

        const separator =
          displaySettings.textFormat === "continuous" ? " " : "\n"
        const groups = []
        let currentGroup = []
        let currentTimeMarker = 30 // Start with 30 seconds

        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i]
          currentGroup.push(segment)

          // Check if this segment should end the current group
          const shouldEndGroup =
            (segment.start <= currentTimeMarker &&
              segment.end >= currentTimeMarker) ||
            i === segments.length - 1 || // Last segment
            (i < segments.length - 1 &&
              segments[i + 1].start > currentTimeMarker)

          if (shouldEndGroup) {
            // Get start time of first segment and end time of last segment in group
            const startTime = currentGroup[0].start
            const endTime = currentGroup[currentGroup.length - 1].end

            const groupText =
              displaySettings.diarizationDisplay === "enabled"
                ? joinSegmentsWithSpeakerChanges(
                    currentGroup,
                    separator,
                    "\n",
                    false
                  )
                : currentGroup.map((seg) => seg.text.trim()).join(separator)

            const formattedStartTime = formatTimeForDisplay(startTime)
            const formattedEndTime = formatTimeForDisplay(endTime)
            groups.push(
              "[" +
                formattedStartTime +
                "-" +
                formattedEndTime +
                "]\n" +
                groupText
            )

            // Reset for next group
            currentGroup = []
            currentTimeMarker += 30

            // Handle case where we need to advance time marker further
            while (
              i < segments.length - 1 &&
              segments[i + 1].start > currentTimeMarker
            ) {
              currentTimeMarker += 30
            }
          }
        }

        return groups.join("\n\n")
      }

      function showError(message) {
        transcriptionArea.innerHTML = `שגיאה: ${message}`
        resetAllState()
      }

      function joinSegmentsWithSpeakerChanges(
        segments,
        continuousSeparator,
        segmentSeparator,
        isHTML = true
      ) {
        if (!segments || segments.length === 0) return ""

        const result = []
        let currentSpeaker = null
        const diarizationEnabled =
          displaySettings.diarizationDisplay === "enabled"

        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i]
          const segmentSpeaker =
            segment.speakers && segment.speakers.length > 0
              ? segment.speakers[0]
              : null

          // Determine if we should show the speaker label (only if diarization is enabled)
          const showSpeakerLabel =
            diarizationEnabled && segmentSpeaker !== currentSpeaker

          // Get segment text with or without speaker label
          const segmentText = showSpeakerLabel
            ? isHTML
              ? getSpeakerLabel(segment) + segment.text.trim()
              : getSpeakerLabelPlain(segment) + segment.text.trim()
            : segment.text.trim()

          if (i === 0) {
            // First segment
            result.push(segmentText)
            currentSpeaker = segmentSpeaker
          } else if (diarizationEnabled && segmentSpeaker !== currentSpeaker) {
            // Speaker changed and diarization enabled - use double line break
            result.push("<br><br>" + segmentText)
            currentSpeaker = segmentSpeaker
          } else {
            // Same speaker OR diarization disabled - use the appropriate separator based on format
            result.push(continuousSeparator + segmentText)
            if (diarizationEnabled) {
              currentSpeaker = segmentSpeaker
            }
          }
        }

        return result.join("")
      }

      function updateTranscriptionDisplay() {
        let result

        if (displaySettings.timestampFormat === "segments") {
          result = formatWithTimecodes(transcriptionSegments)
        } else {
          const continuousSeparator =
            displaySettings.textFormat === "continuous" ? " " : "<br>"
          const segmentSeparator = "<br>"
          result = joinSegmentsWithSpeakerChanges(
            transcriptionSegments,
            continuousSeparator,
            segmentSeparator,
            true
          )
        }

        transcriptionArea.innerHTML = result
        updateTranscriptionDirectionUI()
        copyBtn.disabled = false
        downloadBtn.disabled = false
        downloadDocxBtn.disabled = false
        exportWordsBtn.disabled = false
        downloadMenuBtn.disabled = false
        menuVttBtn.disabled = false
        menuSrtBtn.disabled = false
        menuDocxBtn.disabled = false
        menuJsonBtn.disabled = false
      }

      function updateTextFormatToggleUI() {
        if (!textFormatToggleBtn) return
        const isSegments = displaySettings.textFormat === "segments"
        // Update inline SVG to reflect current mode
        const svg = document.getElementById("text-format-icon")
        if (svg) {
          while (svg.firstChild) svg.removeChild(svg.firstChild)
          if (isSegments) {
            // Segments mode: bullet list (bullets on the right for RTL)
            svg.insertAdjacentHTML(
              "afterbegin",
              '<circle cx="20" cy="6" r="2" fill="currentColor" stroke="none" />\n' +
                '<circle cx="20" cy="12" r="2" fill="currentColor" stroke="none" />\n' +
                '<circle cx="20" cy="18" r="2" fill="currentColor" stroke="none" />\n' +
                '<path d="M17 6H4" />\n' +
                '<path d="M17 12H7" />\n' +
                '<path d="M17 18H4" />'
            )
          } else {
            // Continuous mode: three lines with middle right-aligned
            svg.insertAdjacentHTML(
              "afterbegin",
              '<path d="M4 6h16"/>\n' +
                '<path d="M10 12h10"/>\n' +
                '<path d="M4 18h16"/>'
            )
          }
        }
        textFormatToggleBtn.title = isSegments ? "מצב מקטעים" : "מצב רציף"
        textFormatToggleBtn.setAttribute("aria-pressed", String(isSegments))
        textFormatToggleBtn.classList.toggle("toggle-active", isSegments)
        // No lucide refresh needed for inline SVG
      }

      function updateTimestampsToggleUI() {
        if (!timestampsToggleBtn) return
        const enabled = displaySettings.timestampFormat === "segments"
        timestampsToggleBtn.classList.toggle("toggle-active", enabled)
        timestampsToggleBtn.title = enabled ? "כולל קודי זמן" : "ללא קודי זמן"
        timestampsToggleBtn.setAttribute("aria-pressed", String(enabled))
      }

      function updateDiarizationToggleUI() {
        if (!diarizationToggleBtn) return
        const enabled = displaySettings.diarizationDisplay === "enabled"
        diarizationToggleBtn.classList.toggle("toggle-active", enabled)
        diarizationToggleBtn.title = enabled ? "הצג דוברים" : "הסתר דוברים"
        diarizationToggleBtn.setAttribute("aria-pressed", String(enabled))
      }

      if (textFormatToggleBtn) {
        textFormatToggleBtn.addEventListener("click", () => {
          displaySettings.textFormat =
            displaySettings.textFormat === "segments"
              ? "continuous"
              : "segments"
          localStorage.setItem(
            "displaySettings",
            JSON.stringify(displaySettings)
          )
          updateTextFormatToggleUI()
          if (transcriptionSegments.length > 0) {
            updateTranscriptionDisplay()
          }
        })
      }

      if (timestampsToggleBtn) {
        timestampsToggleBtn.addEventListener("click", () => {
          displaySettings.timestampFormat =
            displaySettings.timestampFormat === "segments" ? "none" : "segments"
          localStorage.setItem(
            "displaySettings",
            JSON.stringify(displaySettings)
          )
          updateTimestampsToggleUI()
          if (transcriptionSegments.length > 0) updateTranscriptionDisplay()
        })
      }

      if (diarizationToggleBtn) {
        diarizationToggleBtn.addEventListener("click", () => {
          displaySettings.diarizationDisplay =
            displaySettings.diarizationDisplay === "enabled"
              ? "disabled"
              : "enabled"
          localStorage.setItem(
            "displaySettings",
            JSON.stringify(displaySettings)
          )
          updateDiarizationToggleUI()
          if (transcriptionSegments.length > 0) updateTranscriptionDisplay()
        })
      }

      function resetUploadState() {
        transcribeBtn.disabled = false
        selectedFile = null
        fileName.textContent = ""
        progressContainer.style.display = "none"
        progressBar.style.width = "0%"
      }

      function resetAllState() {
        transcribeBtn.disabled = false
        selectedFile = null
        fileName.textContent = ""
        progressContainer.style.display = "none"
        progressBar.style.width = "0%"
        copyBtn.disabled = true
        downloadBtn.disabled = true
        downloadDocxBtn.disabled = true
        exportWordsBtn.disabled = true
        downloadMenuBtn.disabled = true
        menuVttBtn.disabled = true
        menuSrtBtn.disabled = true
        menuDocxBtn.disabled = true
        menuJsonBtn.disabled = true
        currentJobId = null
        transcriptionSegments = []
      }

      copyBtn.addEventListener("click", function () {
        // Get plain text content for copying
        const plainText = getPlainTextFromSegments()
        navigator.clipboard
          .writeText(plainText)
          .then(() => {
            showToast("הטקסט הועתק ללוח בהצלחה", "success")
          })
          .catch(() => {
            // Fallback for older browsers
            const range = document.createRange()
            range.selectNode(transcriptionArea)
            window.getSelection().removeAllRanges()
            window.getSelection().addRange(range)
            document.execCommand("copy")
            window.getSelection().removeAllRanges()
            showToast("הטקסט הועתק ללוח בהצלחה", "success")
          })
      })

      downloadBtn.addEventListener("click", function () {
        if (!transcriptionSegments.length) return

        // Generate VTT content
        let vttContent = "WEBVTT\n\n"

        transcriptionSegments.forEach((segment, index) => {
          const startTime = formatTime(segment.start)
          const endTime = formatTime(segment.end)
          vttContent += `${index + 1}\n`
          vttContent += `${startTime} --> ${endTime}\n`
          vttContent += `${segment.text.trim()}\n\n`
        })

        // Create and trigger download
        const blob = new Blob([vttContent], { type: "text/vtt" })
        const url = URL.createObjectURL(blob)
        const a = document.createElement("a")
        a.href = url
        a.download = "subtitles.vtt"
        document.body.appendChild(a)
        a.click()
        document.body.removeChild(a)
        URL.revokeObjectURL(url)
      })

      downloadDocxBtn.addEventListener("click", function () {
        if (!transcriptionSegments.length) return

        try {
          if (
            !window.htmlDocx ||
            typeof window.htmlDocx.asBlob !== "function"
          ) {
            showToast(
              "ספריית יצירת המסמך לא נטענה. בדקו את החיבור ונסו שוב.",
              "error"
            )
            return
          }

          function escapeHtml(text) {
            return (text || "").replace(/[&<>]/g, function (c) {
              return { "&": "&amp;", "<": "&lt;", ">": "&gt;" }[c]
            })
          }

          function buildDocxHTMLFromSegments() {
            const speakerColors = {
              1: "#2196F3",
              2: "#4CAF50",
              3: "#FF9800",
              4: "#E91E63",
              5: "#9C27B0",
              6: "#F44336",
              7: "#00BCD4",
              8: "#8BC34A",
              9: "#FFC107",
              10: "#607D8B",
            }

            const lines = []
            lines.push("<!DOCTYPE html>")
            const docLang =
              typeof getTranscriptionLanguage === "function"
                ? getTranscriptionLanguage()
                : "he"
            const isRTL = ["he", "yi"].includes(docLang)
            const docDir = isRTL ? "rtl" : "ltr"
            const textAlign = isRTL ? "right" : "left"
            lines.push('<html lang="' + docLang + '" dir="' + docDir + '">')
            lines.push("<head>")
            lines.push('<meta charset="utf-8" />')
            lines.push("<style>")
            lines.push(
              'body { font-family: Arial, "Noto Sans Hebrew", "Rubik", sans-serif; direction: ' +
                docDir +
                "; unicode-bidi: embed; }"
            )
            lines.push(
              "h1 { text-align: " +
                textAlign +
                "; font-size: 24pt; margin: 0 0 18pt; }"
            )
            lines.push(
              "p { text-align: " +
                textAlign +
                "; line-height: 1.6; margin: 0 0 10pt; }"
            )
            lines.push("</style>")
            lines.push("</head>")
            lines.push("<body>")
            lines.push("<h1>תמלול</h1>")

            const diarizationEnabled =
              displaySettings.diarizationDisplay === "enabled"
            const separateEachSegment =
              displaySettings.textFormat === "segments"

            if (separateEachSegment) {
              // One paragraph per segment
              for (let i = 0; i < transcriptionSegments.length; i++) {
                const seg = transcriptionSegments[i]
                const text = escapeHtml((seg.text || "").trim())
                const rawSpeaker =
                  seg.speakers && seg.speakers.length > 0
                    ? seg.speakers[0]
                    : null

                if (diarizationEnabled) {
                  if (rawSpeaker) {
                    const speakerNumber =
                      parseInt(rawSpeaker.replace("SPEAKER_", "")) || 0
                    const colorIndex = ((speakerNumber - 1) % 10) + 1
                    const color = speakerColors[colorIndex] || "#000000"
                    const label =
                      (typeof translateSpeakerLabelText === "function"
                        ? translateSpeakerLabelText(docLang, speakerNumber)
                        : "Speaker " + speakerNumber) + ": "
                    lines.push(
                      '<p><span style="color:' +
                        color +
                        '; font-weight:700">' +
                        label +
                        "</span>" +
                        text +
                        "</p>"
                    )
                  } else {
                    const unknownText =
                      typeof translateSpeakerUnknownText === "function"
                        ? translateSpeakerUnknownText(docLang)
                        : "Unknown speaker"
                    lines.push(
                      '<p><span style="font-weight:700">' +
                        unknownText +
                        ": </span>" +
                        text +
                        "</p>"
                    )
                  }
                } else {
                  lines.push("<p>" + text + "</p>")
                }
              }
            } else {
              // Continuous mode: start a new paragraph only on speaker change
              let currentSpeaker = undefined
              let bufferParts = []
              let currentLabelHTML = ""

              const flushParagraph = () => {
                if (bufferParts.length === 0) return
                const content = bufferParts.join(" ").trim()
                if (currentLabelHTML) {
                  lines.push("<p>" + currentLabelHTML + content + "</p>")
                } else {
                  lines.push("<p>" + content + "</p>")
                }
                bufferParts = []
                currentLabelHTML = ""
              }

              for (let i = 0; i < transcriptionSegments.length; i++) {
                const seg = transcriptionSegments[i]
                const rawSpeaker =
                  seg.speakers && seg.speakers.length > 0
                    ? seg.speakers[0]
                    : null
                const segText = escapeHtml((seg.text || "").trim())

                const speakerChanged =
                  i === 0 ? true : rawSpeaker !== currentSpeaker
                if (speakerChanged) {
                  // Emit previous paragraph
                  flushParagraph()
                  // Prepare new label if diarization is enabled
                  if (diarizationEnabled) {
                    if (rawSpeaker) {
                      const speakerNumber =
                        parseInt(rawSpeaker.replace("SPEAKER_", "")) || 0
                      const colorIndex = ((speakerNumber - 1) % 10) + 1
                      const color = speakerColors[colorIndex] || "#000000"
                      const label =
                        (typeof translateSpeakerLabelText === "function"
                          ? translateSpeakerLabelText(docLang, speakerNumber)
                          : "Speaker " + speakerNumber) + ": "
                      currentLabelHTML =
                        '<span style="color:' +
                        color +
                        '; font-weight:700">' +
                        label +
                        "</span>"
                    } else {
                      const unknownText =
                        typeof translateSpeakerUnknownText === "function"
                          ? translateSpeakerUnknownText(docLang)
                          : "Unknown speaker"
                      currentLabelHTML =
                        '<span style="font-weight:700">' +
                        unknownText +
                        ": </span>"
                    }
                  } else {
                    currentLabelHTML = ""
                  }
                  currentSpeaker = rawSpeaker
                }

                if (segText) bufferParts.push(segText)
              }

              // Flush the last paragraph
              flushParagraph()
            }

            lines.push("</body>")
            lines.push("</html>")
            return lines.join("\n")
          }

          const html = buildDocxHTMLFromSegments()
          const blob = window.htmlDocx.asBlob(html)
          const url = URL.createObjectURL(blob)
          const a = document.createElement("a")
          a.href = url
          a.download = "transcription.docx"
          document.body.appendChild(a)
          a.click()
          document.body.removeChild(a)
          URL.revokeObjectURL(url)
        } catch (error) {
          console.error("Error creating DOCX:", error)
          showToast("שגיאה ביצירת קובץ Word. אנא נסה שוב.", "error")
        }
      })

      exportWordsBtn.addEventListener("click", function () {
        if (!transcriptionSegments.length) return

        try {
          // Export all segment data
          const exportData = transcriptionSegments

          const blob = new Blob([JSON.stringify(exportData, null, 2)], {
            type: "application/json",
          })
          const url = URL.createObjectURL(blob)
          const a = document.createElement("a")
          a.href = url
          a.download = "transcription_data.json"
          document.body.appendChild(a)
          a.click()
          document.body.removeChild(a)
          URL.revokeObjectURL(url)
        } catch (error) {
          console.error("Error exporting transcription data:", error)
          showToast("שגיאה בייצוא נתוני התמלול", "error")
        }
      })

      menuVttBtn.addEventListener("click", function () {
        if (!downloadBtn.disabled) {
          downloadBtn.click()
        }
      })
      menuSrtBtn.addEventListener("click", function () {
        if (!transcriptionSegments.length) return

        let srtContent = ""
        transcriptionSegments.forEach((segment, index) => {
          const start = formatTime(segment.start).replace(".", ",")
          const end = formatTime(segment.end).replace(".", ",")
          srtContent += `${
            index + 1
          }\n${start} --> ${end}\n${segment.text.trim()}\n\n`
        })
        const blob = new Blob([srtContent], { type: "text/plain" })
        const url = URL.createObjectURL(blob)
        const a = document.createElement("a")
        a.href = url
        a.download = "subtitles.srt"
        document.body.appendChild(a)
        a.click()
        document.body.removeChild(a)
        URL.revokeObjectURL(url)
      })
      menuDocxBtn.addEventListener("click", function () {
        if (!downloadDocxBtn.disabled) {
          downloadDocxBtn.click()
        }
      })
      menuJsonBtn.addEventListener("click", function () {
        if (!exportWordsBtn.disabled) {
          exportWordsBtn.click()
        }
      })

      function formatTime(seconds) {
        const hours = Math.floor(seconds / 3600)
        const minutes = Math.floor((seconds % 3600) / 60)
        const secs = Math.floor(seconds % 60)
        const ms = Math.floor((seconds % 1) * 1000)
        return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(
          2,
          "0"
        )}:${String(secs).padStart(2, "0")}.${String(ms).padStart(3, "0")}`
      }

      // Custom confirmation dialog
      function showExitWarning() {
        return confirm("תמלול פעיל עדיין רץ, האם לצאת?")
      }

      window.addEventListener("beforeunload", function (e) {
        if (activeTranscription) {
          // Show confirmation dialog
          e.preventDefault()
          e.returnValue = "תמלול פעיל עדיין רץ, האם לצאת?"
          return e.returnValue
        }
      })

      // Handle refresh key combinations
      window.addEventListener("keydown", function (e) {
        if (
          activeTranscription &&
          (e.key === "F5" || (e.key === "r" && (e.ctrlKey || e.metaKey)))
        ) {
          if (!showExitWarning()) {
            e.preventDefault()
            return false
          }
        }
      })

      // Handle clicks on links
      document.addEventListener("click", function (e) {
        if (!activeTranscription) return

        const link = e.target.closest("a")
        if (link && !link.hasAttribute("download")) {
          if (!showExitWarning()) {
            e.preventDefault()
            return false
          }
        }
      })
    </script>
  </body>
</html>
